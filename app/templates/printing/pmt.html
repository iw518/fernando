{% extends "project_home.html" %}
{% import "bootstrap/wtf.html" as wtf %}
{% block css %}
    {{ super() }}
    <link href="{{ url_for('static',filename='css/jqTree/jqtree.css') }} " rel="stylesheet" type="text/css"/>
{% endblock %}

{% block main %}
    {{ super() }}
    <ul class="tabs">
        <li class="active"><a href="#tab1"><i class="fa fa-code"></i>剖面代码</a></li>
        <li><a href="#tab2"><i class="fa fa-eye" aria-hidden="true"></i>剖面预览</a></li>
    </ul>
    <div class="tab_container">
        <div id="tab1" class="tab_content" style="display: none; ">
            <div class="row">
                <div class="col-sm-2" id='tree'></div>
                <div class="col-sm-10" id="section_expand"></div>
            </div>
        </div>
        <div id="tab2" class="tab_content" style="display: block; ">
            <div class="row">
                <div id="svgContainer" class="col-sm-12" align="center"></div>
            </div>
        </div>
    </div>
{% endblock %}

{% block script %}
    {{ super() }}
    <script type="text/javascript" src="{{ url_for('static', filename='js/jqTree/tree.jquery.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/custom/section/data.js') }}"></script>
    <script src="http://apps.bdimg.com/libs/d3/3.4.8/d3.min.js"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/custom/section/texture.js') }}"></script>
    <script>

        /**
         * Created by Administrator on 2017/3/3 0003.
         */

        /**
         A3 PAPER
         */
        $("#svgContainer").empty();
        let scale = 100 * (96 / 2.54);
        let scaleX = {{ paper.scale.x }};
        let scaleY = {{ paper.scale.y }};
        let offsetX = {{paper.offset.x}};
        let offsetY = {{paper.offset.y}};

        //生成svg root
        let paper = d3.select("#svgContainer").append('svg');
        paper.attr('id', 'section')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('viewBox', '0 0 1600 1200')
            .attr("overflow-x", "scroll")
            .attr("overflow-y", "scroll")
            .attr("preserveAspectRatio", "xMinYMin meet");


        //画标题
        let head_layer = paper.append('g');
        head_layer.attr('id', 'head_layer').attr('text-anchor', 'middle');

        let title = head_layer.append('text');
        title.attr('x', '50%').attr('y', 25).attr('font-size', 20);
        title.text("工程地质剖面图");

        let section_name = head_layer.append('text');
        section_name.attr('x', '50%').attr('y', 50).attr('font-size', 20);
        section_name.text("{{ section.name }}--{{ section.name }}'");

        let scale_str = head_layer.append('text');
        scale_str.attr('x', '50%').attr('y', 75).attr('font-size', 20);
        scale_str.text("水平 1：" + scaleX + "    垂直1：" + scaleY);


        paper.append('rect').attr('x', 0)
            .attr('y', 0)
            .attr('width', 1600)
            .attr('height', 1200)
            .attr('stroke', "#000")
            .attr('stroke-width', 5)
            .attr('fill', 'none');


        //画比例尺
        let scale_layer = paper.append('g');
        scale_layer.attr('id', 'scale_layer');
        plotting_scale(15, layer = scale_layer);

        function plotting_scale(n, layer) {
            for (var i = 1; i < n; i++) {
                var rect = layer.append('rect')
                    .attr('x', 10)
                    .attr('y', (i - 1) * 40)
                    .attr('width', 5)
                    .attr('height', 4)
                    .attr('stroke', "#000")
                    .attr('stroke-width', 1);


                if (i % 2 == 1) {
                    layer.append('line').attr('x1', 10).attr('y1', (i - 1) * 40).attr('x2', 50).attr('y2', (i - 1) * 40).style({
                        stroke: "#000",
                        strokeWidth: 1
                    });
                    layer.append('line').attr('x1', 10).attr('y1', (i - 1) * 40).attr('x2', 50).attr('y2', (i - 1) * 40).style({
                        "stroke": "#000",
                        "stroke-width": 1
                    });
                    layer.append('text')
                        .attr('x', 50)
                        .attr('y', (i - 1) * 40)
                        .attr('value', i);
                }
                else {
                    rect.style({
                        "stroke": "#222",
                        "stroke-width": 1
                    });
                }
            }

        }

        let x1, y1, x2, y2;

        /*画勘探孔 */
        let hole_layer = paper.append('g');
        hole_layer.attr('id', 'hole_layer');
        {% for hLine in hLines %}
            x1 = offsetX + '{{ hLine[0].x }}' / scaleX;
            y1 = offsetY - '{{ hLine[0].y }}' / scaleY;
            x2 = offsetX + '{{ hLine[1].x }}' / scaleX;
            y2 = offsetY - '{{ hLine[1].y }}' / scaleY;
            holeName = hole_layer.append('text');
            holeName.text('{{ section.holes[loop.index0].holeName }}');
            holeName.attr('x', parseInt(x1 * scale))
                .attr('y', parseInt(0.022 * scale))
                .attr('font-size', "20")
                .attr('text-anchor', 'middle');

            hole_layer.append('line')
                .attr('x1', parseInt(x1 * scale))
                .attr('y1', parseInt(y1 * scale))
                .attr('x2', parseInt(x2 * scale))
                .attr('y2', parseInt(y2 * scale))
                .attr('stroke', "#000")
                .attr('stroke-width', 2);
        {% endfor %}

        /*画层位线 */
        let curve_layer = paper.append('g');
        curve_layer.attr('id', 'curve_layer');
        {% for layer in layers %}
            {% for line in layer.top_curve.get_lines() %}
                x1 = offsetX + {{line.pt1.x}}/scaleX;
                y1 = offsetY - {{line.pt1.y}}/scaleY;
                x2 = offsetX + {{line.pt2.x}}/scaleX;
                y2 = offsetY - {{line.pt2.y}}/scaleY;
                curve_layer.append('line')
                    .attr('x1', parseInt(x1 * scale))
                    .attr('y1', parseInt(y1 * scale))
                    .attr('x2', parseInt(x2 * scale))
                    .attr('y2', parseInt(y2 * scale))
                    .attr('stroke-width', 1).attr('stroke', 'black');
            {% endfor %}
        {% endfor %}

        /*画填充斜线 */
        let flap_layer = paper.append('g');
        flap_layer.attr('id', 'flap_layer');
        {% for line in lines %}
            x1 = offsetX + {{line.pt1.x}};
            y1 = offsetY - {{line.pt1.y}};
            x2 = offsetX + {{line.pt2.x}};
            y2 = offsetY - {{line.pt2.y}};
            flap_layer.append('line')
                .attr('x1', parseInt(x1 * scale))
                .attr('y1', parseInt(y1 * scale))
                .attr('x2', parseInt(x2 * scale))
                .attr('y2', parseInt(y2 * scale))
                .attr('stroke', "red")
                .attr('stroke-width', 1);
        {% endfor %}


        /*画层号 */
        let layerNo_layer = paper.append('g');
        layerNo_layer.attr('id', 'layerNo_layer');
        {% for layer in layers[0:-1] %}
            {% set outer_loop=loop.index0 %}
            {% for hole in section.holes %}
                {% if hole.layers|length>outer_loop and hole.layers[outer_loop].thickness>0%}
                    {% set x0=section.dss[loop.index0] %}
                    x = offsetX + {{x0}}/scaleX+0.005;
                    {% if loop.index0<section.holes|length-1 %}
                        {% set Bhole=section.holes[loop.index0+1] %}
                        {% if Bhole.layers|length>outer_loop %}
                            {% if Bhole.layers[outer_loop].thickness==0  %}
                                var layerNo = layerNo_layer.append('text');
                                layerNo.text("{{ layer.layerNo }}");
                                y1 = offsetY - '{{ layer.top_curve.x2y(x0).y}}' / scaleY;
                                y2 = offsetY - '{{ layer.bottom_curve.x2y(x0).y}}' / scaleY;
                                y = (y1 + y2) / 2;
                                layerNo.attr('x', parseInt(x * scale))
                                    .attr('y', parseInt(y * scale) + 10)
                                    .attr('font-size', "20");
                            {% endif %}
                        {% endif %}
                    {% else %}
                        var layerNo = layerNo_layer.append('text');
                        layerNo.text("{{ layer.layerNo }}");
                        y1 = offsetY - '{{ layer.top_curve.x2y(x0).y}}' / scaleY;
                        y2 = offsetY - '{{ layer.bottom_curve.x2y(x0).y}}' / scaleY;
                        y = (y1 + y2) / 2;
                        layerNo.attr('x', parseInt(x * scale))
                            .attr('y', parseInt(y * scale) + 10)
                            .attr('font-size', "20");
                    {% endif %}
                {% endif %}

            {% endfor %}
        {% endfor %}



        {#        /*填充剖面 */
                let fill_layer = paper.append('g');
                fill_layer.attr('id', 'fill_layer');

                console.log(view_scale());
                /*粉质粘土 */
                var t0 =
                    textures.paths()
                        .d("siltclay").size(16 * view_scale())
                        .lighter();
                /*粘土 */
                var t1 =
                    textures.paths()
                        .d("clay").size(15 * view_scale())
                        .lighter().stroke("darkorange");

                var t2 = textures.lines()
                    .lighter();
                paper.call(t0);
                paper.call(t1);

                {% for layer in layers[0:-1] %}
                    polygon_points = '';
                    {% for point in layer.top_curve.get_points() %}
                        x1 = (offsetX + {{ point.x }} /scaleX)* scale;
                        y1 = (offsetY - {{ point.y }} /scaleY)* scale;
                        polygon_points = polygon_points + ' ' + parseInt(x1) + ',' + parseInt(y1);
                    {% endfor %}
                    {% for point in layer.bottom_curve.get_points()[::-1] %}
                        x1 = (offsetX + {{ point.x }} /scaleX)* scale;
                        y1 = (offsetY - {{ point.y }} /scaleY)* scale;
                        polygon_points = polygon_points + ' ' + parseInt(x1) + ',' + parseInt(y1);
                    {% endfor %}
                    console.log(polygon_points);
                    fill_layer.append('polygon').attr('points', polygon_points).style(
                        "fill", t0.url());
                {% endfor %}#}

        function view_scale() {
            //计算宽度
            min_scale = Math.min(1600 / $('#section').width(), 1200 / $('#section').height());
            return parseInt(min_scale * 10) / 10;
        }

        function view_scale0() {
            //计算宽度
            var obj = document.getElementById("section");
            var style = null;
            if (window.getComputedStyle) {
                style = window.getComputedStyle(obj, null);    // 非IE
            } else {
                style = obj.currentStyle;  // IE
            }
            min_scale = Math.min(1600 / style.width.slice(0, -2), 1200 / style.height.slice(0, -2));
            return parseInt(min_scale * 10) / 10;
        }

    </script>
{% endblock %}
